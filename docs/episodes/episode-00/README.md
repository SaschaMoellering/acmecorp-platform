# Episode 0 — Course Overview & Goals

## Duration
~7–8 minutes

## Purpose
Set expectations for the course. Explain what the AcmeCorp Platform is, why it exists, and how this course differs from typical cloud or Java tutorials.

This episode allows viewers to decide whether this **paid deep-dive course** is the right investment for them.

## Target Audience
- Senior Java developers  
- Software architects  
- Platform, cloud, and infrastructure engineers  
- Engineers who already know frameworks and tools, but want to understand **trade-offs and runtime behavior**

## Who This Course Is (and Is Not)

**This course is for people who:**
- have built real systems and felt their limits
- care about startup time, memory usage, observability, and operability
- want to understand *why* architectural decisions matter at runtime
- are comfortable reading code and infrastructure definitions

**This course is not for people who:**
- want framework tutorials or “Hello World” examples
- are looking for certification preparation
- expect one-size-fits-all best practices

## High-Level Narrative

Most modern systems fail not because of missing features, but because of **misunderstood trade-offs**.

This course is built around a realistic reference system — the *AcmeCorp Platform* — and uses it to explore how architecture, runtime behavior, performance, observability, and infrastructure interact in practice.

The goal is not to teach tools in isolation, but to develop **system intuition**.

## Teaching Philosophy

This course follows a few core principles:

- **Production-first thinking**  
  Every topic is framed around real-world behavior, not demos.

- **Trade-offs over dogma**  
  There are no perfect architectures — only informed decisions.

- **Measure, don’t assume**  
  Observed behavior matters more than expectations.

- **Runtime matters**  
  Startup time, memory usage, readiness, and failure modes are first-class concerns.

## Course Structure (High Level)

The course is structured as a deliberate progression:

1. Context and architecture  
2. Local development and service interaction  
3. API boundaries and gateways  
4. Observability and system signals  
5. Application-level performance pitfalls  
6. JVM startup and container behavior  
7. JVM evolution and version trade-offs  
8. Cloud deployment decisions  
9. Secure data planes  
10. Performance signals and interpretation  
11. Cutting-edge JVM evaluation  
12. Asynchronous messaging fundamentals  
13. AI for developer productivity  
14. Benchmarking methodology

Each episode builds on the previous one, but most episodes can also be watched independently.

## What Is Shown in This Episode
- Slides only (no code, no terminal)
- Course goals and structure
- Examples of the kinds of problems the course will address

## What Is Intentionally Deferred
- Any technical deep dive
- Code or infrastructure walkthroughs
- Tool-specific details

## Closing Message

This course exists because modern systems fail less often due to missing features — and more often due to **misunderstood trade-offs**.

If you care about building systems that behave well under real-world conditions, this course is designed for you.

